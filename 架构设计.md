# S3 服务器架构设计

## 1. 目标与约束

| 项目 | 说明 |
|------|------|
| **平台** | Linux，可使用 Linux 专有 API（io_uring、POSIX 等） |
| **语言** | C++ |
| **认证** | 仅 S3 签名 v2（Query 签名），验证只考虑 v2 |
| **文件 I/O** | 本地文件读写必须使用 **io_uring**（liburing） |
| **消息缓冲** | 沿用现有 **msg**（msg_buffer4，`x_buf_pool_t` + `x_msg_t`），不修改 |
| **功能** | 对象存储：GET/PUT 对象、删除对象、列举对象；桶：创建桶、删除桶；元数据单独存储 |
| **元数据** | 使用**一个文件**存储元数据（简化实现，如 SQLite 单库），含桶、对象信息 |
| **并发** | 支持多线程（监听 + 工作线程池或每连接一线程） |

---

## 2. 整体架构图

```
                    ┌─────────────────────────────────────────────────────────┐
                    │                      S3 Server (Linux)                   │
                    │                                                          │
  [Client]  ──TCP──►│  ┌──────────┐    ┌─────────────┐    ┌─────────────────┐  │
                    │  │ Listener │───►│  Worker     │───►│ HTTP Parser     │  │
                    │  │ (accept) │    │  Thread(s)  │    │ → HttpRequest   │  │
                    │  └──────────┘    └──────┬──────┘    └────────┬────────┘  │
                    │                          │                    │          │
                    │                          ▼                    ▼          │
                    │                   ┌─────────────┐    ┌─────────────────┐ │
                    │                   │ x_buf_pool_t │    │ S3 Auth (v2)    │ │
                    │                   │ x_msg_t      │    │ Query 验签      │ │
                    │                   │ (msg 不动)   │    └────────┬────────┘ │
                    │                   └──────┬──────┘             │          │
                    │                          │                     ▼          │
                    │                          │            ┌─────────────────┐ │
                    │                          │            │ S3 Handler      │ │
                    │                          │            │ 桶/对象 路由    │ │
                    │                          │            │ GET/PUT/DEL/LIST│ │
                    │                          │            └────────┬────────┘ │
                    │                          │                     │          │
                    │                          │     ┌───────────────┼────────┐ │
                    │                          │     ▼               ▼        ▼ │
                    │                          │  ┌──────────┐  ┌──────┐  ┌──────────────┐
                    │                          │  │ 元数据   │  │ POSIX│  │ io_uring     │
                    │                          │  │ (单文件) │  │ 目录 │  │ 文件 读/写   │
                    │                          │  │ meta 层  │  │ 操作 │  │ (liburing)   │
                    │                          │  └────┬─────┘  └──┬───┘  └──────┬───────┘
                    │                          │       │           │             │           │
                    │                          │       ▼           └──────┬──────┘           │
                    │                          │  data_root/s3_meta.db     data_root/s3/...  │
                    │                          │  (或同目录单文件)         (对象文件)        │
                    │                          │                                                │
                    │                          ▼                                                │
                    │                   ┌─────────────┐    S3 Response                          │
                    │                   │ 写回 socket │◄─── 状态行/头/XML/体                   │
                    │                   │ (x_msg_t)   │                                         │
                    │                   └─────────────┘                                         │
                    └─────────────────────────────────────────────────────────┘
```

---

## 3. 分层说明（每层存在、不深入）

### 3.1 网络层 (net)

- **Listener**：TCP `bind` / `listen` / `accept`；可选使用 epoll/select 等多路复用；接受连接后把 fd 交给工作线程或放入任务队列。
- **Connection**：单连接上的读/写；读入数据写入 `x_msg_t`（经 pool），写出时从 `x_msg_t` 取 `get_iovec` + `writev`；关闭连接。
- **要求**：与 msg 配合，不替换 msg；多线程下连接由不同工作线程处理，避免共享连接状态。

### 3.2 HTTP 解析层 (http)

- **http_parser**：解析请求行（Method、URI、Version）、请求头；输入来自已读入的 `x_msg_t`（可线性化或按 segment 解析）。
- **http_request**：解析结果结构体，至少包含：Method、URI、Path（规范化路径）、Query（用于 v2 验签）、Host 等；供路由与 S3 Auth 使用。
- **要求**：只做解析，不处理业务；路径规范化（去多余 `/`、禁止 `..`）在本层或路由前完成。

### 3.3 认证层 (s3/auth)

- **S3 签名 v2**：仅支持 **Query 签名**；从 URI Query 取 `AWSAccessKeyId`、`Signature`、`Expires` 等；用配置的 SecretKey 做 HMAC-SHA1 重算签名并比对；校验 `Expires` 是否过期。
- **失败**：返回 403，响应写入 `x_msg_t` 后发送并断开。
- **要求**：验证只考虑 v2，不实现 Header 签名或 v4。

### 3.4 S3 业务层 (s3/handler + s3/response)

- **路由**：根据 Method + Path 区分桶级 / 对象级。
- **桶级**：`PUT /bucket` → CreateBucket；`DELETE /bucket` → DeleteBucket；`GET /bucket` → LIST。
- **对象级**：`GET /bucket/obj` → GET Object；`PUT /bucket/obj` → PUT Object；`DELETE /bucket/obj` → DELETE Object。
- **存储映射**：桶与对象的**元数据**读写经 **meta 层**（单文件）；对象**内容**仍经 io_uring 读/写本地文件（路径可由 `objects.storage_path` 或约定 `data_root/s3/bucket/key` 得到）。LIST 等可查 meta 得到 Key/Size/LastModified，再按需读文件。
- **response**：按状态码、头、body（含 S3 风格 XML 错误体）组装到 `x_msg_t`，由 connection 写出。

### 3.5 元数据存储层 (meta)

- **形态**：使用**一个文件**存储全部元数据，**已采用方案 A：行式文本**（见 3.5.2），无外部依赖，由 meta 层手写解析与序列化。
- **职责**：存储桶信息、对象信息；供 s3/handler 在 CreateBucket/DeleteBucket/LIST/GET/PUT/DELETE 时读写。
- **表设计**（见下节）：buckets、objects。
- **要求**：多线程访问时对 meta 文件或 meta 层内部加**互斥锁**（如单写锁或读写锁），保证并发安全；接口对 handler 暴露增删改查即可，不深入实现细节。**在元数据相关代码中用注释标明元数据文件规则**（见 3.5.2），便于维护与排查。

#### 3.5.1 数据库表设计（元数据单文件内结构）

**buckets**

| 列名       | 类型        | 说明 |
|------------|-------------|------|
| id         | integer     | 主键 |
| name       | text        | 桶名，唯一 |
| created_at | timestamp   | 创建时间 |
| owner_id   | text        | 拥有者，本方案用访问密钥（AccessKey）标识 |

**objects**

| 列名          | 类型        | 说明 |
|---------------|-------------|------|
| id            | integer     | 主键 |
| bucket_id     | integer     | 外键 → buckets.id |
| key           | text        | 对象键 |
| size          | integer     | 对象大小（字节） |
| last_modified | timestamp   | 最后修改时间 |
| etag          | text        | 实体标签（可选） |
| storage_path  | text        | 对象在文件系统中的路径 |
| acl           | text        | 访问控制，如 private、public-read |

#### 3.5.2 方案 A：行式文本格式（已采用）

元数据使用**一个文本文件**，**行式、类型前缀、制表符分隔**，无外部依赖，由 meta 层手写解析与序列化。

**文件路径**

- 路径：`<data_root>/s3_meta.dat`（与 config 的 data_root 一致）。
- 读写方式：POSIX `open/read/write/close` 或 C++ `std::ifstream`/`std::ofstream`；对象内容仍走 io_uring，meta 文件用普通文件 API 即可。

**行格式与区分规则**

- **一条记录一行**；行内用**制表符 `\t`** 分隔字段；**首字段为类型**，用于在单文件中区分桶与对象。
- **桶**：首字段 `B`，后续字段顺序与 3.5.1 的 buckets 表一致。  
  行格式：`B\t<id>\t<name>\t<created_at>\t<owner_id>`
- **对象**：首字段 `O`，后续字段顺序与 objects 表一致。  
  行格式：`O\t<id>\t<bucket_id>\t<key>\t<size>\t<last_modified>\t<etag>\t<storage_path>\t<acl>`
- **如何分辨各条记录**：按行读取，根据**第一字段**判断——`B` 为 bucket，`O` 为 object；类型前缀 + 换行即唯一区分，无需在文件内再分块或分段。

**next_id 行（ID 分配）**

- 文件**首行**固定为 next_id 行，格式：`N\t<bucket_next_id>\t<object_next_id>`
- 读入时解析该行得到下次创建桶/对象时使用的 id；每次创建桶或对象后自增对应 next_id，写回时首行更新为该行。
- 若文件为空或首行不是 `N\t...`，则视为新库，bucket_next_id=1、object_next_id=1。

**字段与特殊字符**

- 时间戳建议格式：`YYYY-MM-DDTHH:MM:SSZ`（如 `2025-01-01T00:00:00Z`），便于解析与可读。
- **特殊字符**：`name`、`key`、`storage_path`、`owner_id`、`etag`、`acl` 等字段**禁止包含制表符 `\t` 和换行 `\n`**（简单实现）；若后续需要支持，可约定转义（如 `\t`→`\\t`，`\n`→`\\n`），写入时转义、读出时反转义。

**读写流程**

- **读（load）**：整文件读入内存 → 解析首行得 next_id → 按行解析，首字段 `B` 的解析为 Bucket 入 buckets 列表，首字段 `O` 的解析为 Object 入 objects 列表。
- **写（save）**：将 next_id 行 + 全部 B 行 + 全部 O 行按上述格式拼成文本，**先写入临时文件**（如 `s3_meta.dat.tmp`），成功后再 `rename` 覆盖 `s3_meta.dat`，避免写坏原文件。

**并发**

- 多线程下对 meta 的**读/写**加互斥（如全局 `std::mutex` 或文件锁）；读可并发、写时独占，或简化为每次访问 meta 都加锁。由 meta 层封装，handler 只调用 meta 接口。

**meta 层接口约定（供 s3/handler 使用）**

- **初始化/加载**：`init(data_root)` 或 `load(path)`，读入 `s3_meta.dat` 到内存。
- **持久化**：`save()`，将内存中数据按行式格式写回文件（经临时文件 + rename）。
- **桶**：`get_bucket_by_name(name)`、`create_bucket(name, owner_id)`、`delete_bucket(id)`、`list_buckets()`（按需）。
- **对象**：`get_object(bucket_id, key)`、`list_objects(bucket_id)`、`put_object(...)`、`delete_object(bucket_id, key)`；内部维护 next_id 与内存中的 buckets/objects，在 put/delete 后调用 `save()` 或按策略延迟写回。

**s3_meta.dat 文件示例**

```
N	2	2
B	1	mybucket	2025-01-01T00:00:00Z	testkey
O	1	1	a.txt	100	2025-01-01T00:00:00Z		/data/s3/mybucket/a.txt	private
```

- 第 1 行：`N\t2\t2` 表示下一桶 id=2、下一对象 id=2。
- 第 2 行：桶 id=1，name=mybucket，created_at，owner_id=testkey。
- 第 3 行：对象 id=1，bucket_id=1，key=a.txt，size=100，last_modified，etag 空，storage_path，acl=private。  
（实际文件中为制表符 `\t` 分隔，此处用空格示意。）

**代码注释约定**

- 在**元数据相关代码**（meta 层及所有解析/序列化 `s3_meta.dat` 的逻辑）中，应使用**注释标明元数据文件规则**，包括但不限于：
  - 文件路径：`<data_root>/s3_meta.dat`；
  - 首行格式：`N\t<bucket_next_id>\t<object_next_id>`；
  - 桶行格式：首字段 `B`，字段顺序 id、name、created_at、owner_id，制表符分隔；
  - 对象行格式：首字段 `O`，字段顺序 id、bucket_id、key、size、last_modified、etag、storage_path、acl，制表符分隔；
  - 字段禁止字符：`\t`、`\n`（或约定的转义规则）；
  - 写回方式：先写临时文件再 rename。
- 可在文件头、load/save 函数旁、解析/拼接行逻辑处添加简短注释，引用本设计（如「参见架构设计 3.5.2」），保证规则在代码中可追溯。

### 3.6 文件 I/O 层（io_uring + POSIX）

- **io_uring（必须）**：对象**文件内容**的读/写必须通过 **io_uring**（liburing）完成。
  - GET Object：openat → io_uring read → 数据进 pool/msg → close。
  - PUT Object：openat → io_uring write（数据来自 `x_msg_t` 的 get_iovec/copy_out）→ close。
- **POSIX**：目录与删除用现有 POSIX 即可（不强制 io_uring）：
  - CreateBucket：`mkdir`；DeleteBucket：`rmdir`（桶为空）；LIST：`opendir`/`readdir`/`stat`/`closedir`；DELETE Object：`unlink`。
- **要求**：GET/PUT 的文件读写路径必须经过 io_uring 封装层，不能直接 read/write。

### 3.7 配置与入口 (config + server.cc)

- **config**：提供 data_root、AccessKey、SecretKey、监听地址/端口等；从环境变量或配置文件读取，只读。
- **server.cc**：创建 `x_buf_pool_t`、加载配置、启动 Listener、accept 后分发给工作线程；每个连接上：读请求 → HTTP 解析 → S3 Auth(v2) → S3 Handler → 写响应。

---

## 4. 模块与目录（与现有结构一致）

| 模块 | 路径 | 职责概要 |
|------|------|----------|
| **msg** | include/msg/, src/msg/ | 消息池与消息视图（**不动**） |
| **config** | include/config/, src/config/ | 配置加载与访问 |
| **net** | include/net/, src/net/ | Listener、Connection |
| **http** | include/http/, src/http/ | http_parser、http_request |
| **meta** | include/meta/, src/meta/ | 元数据存储（方案 A：行式文本单文件 s3_meta.dat，桶、对象） |
| **io_uring** | include/io_uring/, src/io_uring/ | 文件 read/write 封装（liburing） |
| **s3** | include/s3/, src/s3/ | auth(v2)、handler、response |

入口：`src/server.cc`（main + 连接分发）。

---

## 5. 数据流（单请求）

1. **读入**：Connection 从 socket 读到 `x_msg_t`（经 pool）。
2. **解析**：http_parser 产出 HttpRequest（Method、Path、Query、Host）。
3. **认证**：s3/auth 从 Query 做 v2 验签；失败则 response 写 403 到 `x_msg_t`，发送后断开。
4. **路由**：s3/handler 根据 Method+Path 判定 CreateBucket / DeleteBucket / LIST / GET / PUT / DELETE。
5. **执行**：
   - **桶**：CreateBucket/DeleteBucket 读写 **meta**（buckets），必要时配合目录 mkdir/rmdir。
   - **LIST**：查 **meta**（objects，按 bucket_id）得 Key/Size/LastModified，拼 XML。
   - **GET**：从 **meta** 取对象记录（含 storage_path），io_uring 读该路径文件 → 填入 `x_msg_t`。
   - **PUT**：写对象内容到文件（io_uring），再写 **meta**（objects：bucket_id、key、size、last_modified、storage_path 等）。
   - **DELETE**：从 **meta** 删对象记录，unlink 对应 storage_path。
6. **写出**：s3/response 组状态行+头+体到 `x_msg_t`，Connection 用 get_iovec + writev 发送。

全程使用同一套 **msg**（x_buf_pool_t + x_msg_t），不引入新缓冲抽象；元数据读写统一经 **meta** 单文件。

---

## 6. 多线程模型

- **监听线程**：单线程 accept，得到 client fd 后交给工作线程（或投入任务队列）。
- **工作线程**：每个连接由**一个**工作线程负责该连接的读→解析→认证→处理→写；同一连接不在多线程间共享，避免锁。
- **io_uring 与线程**：建议**每工作线程一个 io_uring 实例**，该线程上的 GET/PUT 只在本线程的 ring 上提交与收割，避免跨线程共享 ring。
- **pool**：`x_buf_pool_t` 若多线程共享，则 pool 的 get/put 需线程安全（或每线程一个 pool，视现有 msg 实现而定）；**msg 不动**即按现有约定使用。

---

## 7. io_uring 使用范围（Linux）

- **必须用 io_uring 的**：对象文件的 **read**、**write**（GET/PUT 的文件内容读写）。
- **可用 POSIX 的**：openat/close 可用同步或 io_uring；目录 mkdir/rmdir/readdir、stat、unlink 用 POSIX 即可。
- **依赖**：liburing；构建与运行环境需提供 liburing。
- **接口形态**：对 s3/handler 暴露“同步风格”的封装即可（内部 submit + wait），例如：`read_file(path, buf, size)`、`write_file(path, buf, size)`，便于与现有 handler 对接。

---

## 8. S3 API 与存储约定（简要）

- **桶**：Path 仅一层或以 `/` 结尾视为桶；对应 **meta.buckets** 记录及可选目录 `data_root/s3/<bucket>`。
- **对象**：Path 多于一层为对象；对应 **meta.objects** 记录，`storage_path` 指向实际文件（如 `data_root/s3/<bucket>/<key>` 或内部路径）。
- **操作**：
  - CreateBucket：写 **meta**（buckets），可选 `mkdir`；已存在可 200/409。
  - DeleteBucket：查 **meta** 桶下无对象则删 **meta** 桶记录，可选 `rmdir`；非空 409。
  - LIST：查 **meta**（objects 按 bucket_id），拼 ListBucketResult XML（Key/Size/LastModified）。
  - GET Object：从 **meta** 取 storage_path，io_uring 读该文件，响应带 Content-Length 和 body。
  - PUT Object：io_uring 写文件得到 storage_path，写/更新 **meta**（objects）。
  - DELETE Object：删 **meta** 对象记录，unlink(storage_path)，404/204。
- **错误**：4xx/5xx 用 S3 风格 XML 或简短 body，经 s3/response 写入 `x_msg_t`。

---

## 9. 依赖关系（自底向上）

```
msg (不动)
  ↑
config, net(依赖 msg), http(依赖 msg), io_uring(仅 liburing), meta(单文件，方案 A 行式文本)
  ↑
s3/auth(依赖 config, http), s3/response(依赖 msg)
  ↑
s3/handler(依赖 config, msg, s3/response, http, io_uring, meta)
  ↑
server.cc(依赖 config, net, http, s3/auth, s3/handler, s3/response, msg)
```

---

## 10. 实现要点（不深入）

- **路径安全**：Path 规范化后禁止 `..`；storage_path 与本地路径严格限制在 data_root 下。
- **元数据单文件**：无外部依赖时采用 3.5.2 的**行式文本**（`data_root/s3_meta.dat`）：每行一条记录，首字段 B/O 区分桶与对象，字段用 `\t` 分隔；整文件读入→解析→修改→整文件写回（建议先写临时文件再 rename）。多线程下对 meta 文件加锁（如单写锁）保证并发安全。**元数据相关代码中应用注释标明元数据文件规则**（路径、首行 N、B/O 行格式与字段顺序、禁止字符、写回方式等），参见 3.5.2。
- **LIST**：从 **meta.objects** 按 bucket_id 查询，只列该桶下对象（一层 Key）；拼 ListBucketResult XML。
- **GET/PUT**：小文件整体读写；PUT 时生成 storage_path（如 `data_root/s3/<bucket>/<key>` 或带 UUID 的内部路径），写文件后写 meta；GET 从 meta 取 storage_path 再 io_uring 读。
- **错误码**：404 NoSuchBucket/NoSuchKey、403 认证失败、409 BucketNotEmpty/BucketAlreadyExists、503 内部错误等，由 response 统一组 XML/体。

本架构满足：S3 基本设计要求、各层均有且边界清晰、认证仅 v2、io_uring 用于对象文件读写、**元数据单文件存储**（桶、对象）、Linux 运行、msg 不动、支持 GET/PUT/删除/列举及多线程。本项目不考虑分块/分片上传。
